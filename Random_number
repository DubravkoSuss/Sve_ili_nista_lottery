import os
import random
import time
import hashlib
import numpy as np
from collections import Counter, defaultdict
import struct

class CroatianLotteryAnalyzer:
    def __init__(self):
        """Initialize with Croatian lottery historical data."""
        # Historical data from Croatian "Sve ili ni≈°ta" lottery
        self.historical_draws = [
            [1, 2, 5, 6, 7, 8, 9, 16, 18, 19, 22],
            [1, 2, 5, 6, 10, 13, 14, 17, 18, 19, 21],
            [1, 4, 5, 8, 10, 11, 18, 19, 20, 21, 22],
            [1, 3, 6, 9, 11, 14, 15, 18, 19, 20, 21],
            [1, 2, 3, 4, 8, 11, 12, 14, 16, 18, 21],
            [1, 2, 3, 4, 5, 9, 12, 16, 18, 20, 22],
            [1, 2, 3, 4, 5, 9, 11, 15, 16, 20, 21],
            [4, 5, 6, 10, 11, 14, 16, 17, 18, 19, 20],
            [1, 2, 5, 6, 8, 9, 10, 18, 19, 20, 21],
            [2, 5, 6, 7, 10, 14, 15, 16, 18, 20, 22],
            [3, 5, 6, 8, 9, 10, 11, 16, 17, 19, 21],
            [1, 4, 7, 8, 9, 13, 14, 15, 17, 20, 22],
            [2, 4, 5, 8, 10, 12, 16, 19, 20, 21, 22],
            [1, 3, 5, 7, 9, 12, 14, 15, 16, 20, 22],
            [3, 4, 6, 7, 8, 9, 11, 13, 18, 21, 22],
            [2, 3, 4, 5, 6, 11, 16, 17, 18, 19, 20],
            [1, 2, 3, 4, 9, 11, 12, 13, 16, 18, 19],
            [1, 2, 3, 4, 5, 6, 7, 10, 11, 15, 21],
            [1, 5, 6, 7, 8, 9, 16, 18, 20, 21, 22],
            [1, 2, 5, 7, 8, 13, 14, 15, 16, 17, 20],
            [1, 3, 5, 6, 8, 9, 14, 15, 16, 17, 21],
            [1, 2, 3, 4, 7, 12, 13, 14, 18, 19, 22],
            [2, 4, 5, 6, 7, 9, 10, 11, 12, 18, 22],
            [2, 3, 5, 7, 9, 10, 11, 13, 15, 18, 21],
            [2, 3, 4, 5, 6, 8, 10, 17, 19, 21, 22],
            [1, 2, 4, 8, 9, 10, 14, 18, 20, 21, 22],
            [5, 6, 7, 8, 9, 12, 17, 18, 19, 21, 22],
            [1, 3, 4, 7, 8, 10, 12, 13, 14, 18, 20],
            [1, 2, 4, 5, 6, 8, 10, 12, 13, 15, 22],
            [4, 5, 6, 10, 11, 14, 17, 18, 20, 21, 22],
        ]
        
        # Range definitions
        self.low_range = list(range(1, 8))      # 1-7
        self.mid_range = list(range(8, 16))     # 8-15
        self.high_range = list(range(16, 23))   # 16-22
        
        self.all_numbers = list(range(1, 23))
        
        # Analysis results
        self.number_frequencies = None
        self.clustering_patterns = None
        self.most_common_patterns = None
        
    def analyze_historical_data(self):
        """Comprehensive analysis of historical lottery data."""
        print("=" * 60)
        print("CROATIAN 'SVE ILI NI≈†TA' LOTTERY ANALYSIS")
        print("=" * 60)
        print(f"Analyzing {len(self.historical_draws)} historical draws\n")
        
        # 1. Number frequency analysis
        self._analyze_number_frequencies()
        
        # 2. Clustering pattern analysis
        self._analyze_clustering_patterns()
        
        # 3. Consecutive number analysis
        self._analyze_consecutive_patterns()
        
        # 4. Even/Odd analysis
        self._analyze_even_odd_distribution()
        
        # 5. Sum analysis
        self._analyze_sum_patterns()
        
    def _analyze_number_frequencies(self):
        """Analyze how often each number appears."""
        print("üìä NUMBER FREQUENCY ANALYSIS")
        print("-" * 40)
        
        all_numbers_drawn = []
        for draw in self.historical_draws:
            all_numbers_drawn.extend(draw)
        
        self.number_frequencies = Counter(all_numbers_drawn)
        
        # Expected frequency
        expected_freq = (len(self.historical_draws) * 11) / 22
        
        print(f"Expected frequency per number: {expected_freq:.1f} times")
        print("\nMost frequent numbers:")
        for num, count in self.number_frequencies.most_common(10):
            deviation = count - expected_freq
            print(f"  {num:2d}: {count:3d} times (deviation: {deviation:+.1f})")
        
        print("\nLeast frequent numbers:")
        for num, count in self.number_frequencies.most_common()[-10:]:
            deviation = count - expected_freq
            print(f"  {num:2d}: {count:3d} times (deviation: {deviation:+.1f})")
        
        print()
        
    def _analyze_clustering_patterns(self):
        """Analyze clustering in low-mid-high ranges."""
        print("üéØ CLUSTERING PATTERN ANALYSIS")
        print("-" * 40)
        
        clustering_data = []
        
        for draw in self.historical_draws:
            low_count = sum(1 for n in draw if n in self.low_range)
            mid_count = sum(1 for n in draw if n in self.mid_range)
            high_count = sum(1 for n in draw if n in high_range)
            
            clustering_data.append((low_count, mid_count, high_count))
        
        self.clustering_patterns = Counter(clustering_data)
        self.most_common_patterns = self.clustering_patterns.most_common(5)
        
        print("Most common Low-Mid-High patterns:")
        for pattern, count in self.most_common_patterns:
            percentage = (count / len(self.historical_draws)) * 100
            low, mid, high = pattern
            
            # Identify pattern type
            if max(low, mid, high) >= 5:
                pattern_type = "HEAVY clustering"
            elif max(low, mid, high) >= 4:
                pattern_type = "Moderate clustering"
            else:
                pattern_type = "Balanced"
            
            print(f"  ({low}-{mid}-{high}): {count:2d} times ({percentage:5.1f}%) - {pattern_type}")
        
        # Calculate clustering probability by range
        low_heavy = sum(1 for l, m, h in clustering_data if l >= 4)
        mid_heavy = sum(1 for l, m, h in clustering_data if m >= 4)
        high_heavy = sum(1 for l, m, h in clustering_data if h >= 4)
        
        total = len(clustering_data)
        print(f"\nClustering probabilities (4+ numbers):")
        print(f"  Low range (1-7):   {low_heavy:2d}/{total} ({low_heavy/total*100:.1f}%)")
        print(f"  Mid range (8-15):  {mid_heavy:2d}/{total} ({mid_heavy/total*100:.1f}%)")
        print(f"  High range (16-22): {high_heavy:2d}/{total} ({high_heavy/total*100:.1f}%)")
        
        print()
        
    def _analyze_consecutive_patterns(self):
        """Analyze consecutive number patterns."""
        print("üî¢ CONSECUTIVE NUMBER ANALYSIS")
        print("-" * 40)
        
        consecutive_counts = []
        for draw in self.historical_draws:
            max_consecutive = 1
            current_consecutive = 1
            
            for i in range(1, len(draw)):
                if draw[i] == draw[i-1] + 1:
                    current_consecutive += 1
                    max_consecutive = max(max_consecutive, current_consecutive)
                else:
                    current_consecutive = 1
            
            consecutive_counts.append(max_consecutive)
        
        consecutive_counter = Counter(consecutive_counts)
        
        print("Consecutive number frequency:")
        for length in sorted(consecutive_counter.keys()):
            count = consecutive_counter[length]
            percentage = (count / len(consecutive_counts)) * 100
            print(f"  {length} consecutive: {count:2d} times ({percentage:.1f}%)")
        
        print()
        
    def _analyze_even_odd_distribution(self):
        """Analyze even/odd distribution."""
        print("‚öñÔ∏è  EVEN/ODD DISTRIBUTION ANALYSIS")
        print("-" * 40)
        
        even_odd_patterns = []
        for draw in self.historical_draws:
            even_count = sum(1 for n in draw if n % 2 == 0)
            odd_count = 11 - even_count
            even_odd_patterns.append((even_count, odd_count))
        
        pattern_counter = Counter(even_odd_patterns)
        
        print("Even-Odd distribution:")
        for (even, odd), count in pattern_counter.most_common():
            percentage = (count / len(even_odd_patterns)) * 100
            print(f"  {even} even, {odd} odd: {count:2d} times ({percentage:.1f}%)")
        
        print()
        
    def _analyze_sum_patterns(self):
        """Analyze sum of drawn numbers."""
        print("‚ûï SUM PATTERN ANALYSIS")
        print("-" * 40)
        
        sums = [sum(draw) for draw in self.historical_draws]
        
        mean_sum = np.mean(sums)
        std_sum = np.std(sums)
        theoretical_mean = (1 + 22) * 11 / 2
        
        print(f"Theoretical mean sum: {theoretical_mean:.1f}")
        print(f"Actual mean sum: {mean_sum:.1f}")
        print(f"Standard deviation: {std_sum:.1f}")
        print(f"Range: {min(sums)} to {max(sums)}")
        print(f"68% confidence interval: {mean_sum-std_sum:.0f} to {mean_sum+std_sum:.0f}")
        print(f"95% confidence interval: {mean_sum-2*std_sum:.0f} to {mean_sum+2*std_sum:.0f}")
        
        print()
        
    def generate_statistically_informed_combination(self, method="clustering"):
        """Generate combination based on statistical analysis."""
        
        if method == "clustering":
            return self._generate_clustering_based()
        elif method == "frequency":
            return self._generate_frequency_based()
        elif method == "balanced":
            return self._generate_balanced()
        elif method == "chaos":
            return self._generate_chaos_based()
        else:
            return self._generate_clustering_based()
    
    def _generate_clustering_based(self):
        """Generate based on most common clustering pattern."""
        # Use most common pattern
        most_common_pattern = self.most_common_patterns[0][0]
        low_target, mid_target, high_target = most_common_pattern
        
        # Select numbers from each range based on frequency
        low_candidates = sorted([(n, self.number_frequencies[n]) for n in self.low_range], 
                               key=lambda x: x[1], reverse=True)
        mid_candidates = sorted([(n, self.number_frequencies[n]) for n in self.mid_range], 
                               key=lambda x: x[1], reverse=True)
        high_candidates = sorted([(n, self.number_frequencies[n]) for n in self.high_range], 
                                key=lambda x: x[1], reverse=True)
        
        selected = []
        
        # Add some randomness to selection
        low_pool = [n for n, f in low_candidates[:low_target+2]]
        mid_pool = [n for n, f in mid_candidates[:mid_target+3]]
        high_pool = [n for n, f in high_candidates[:high_target+2]]
        
        random.shuffle(low_pool)
        random.shuffle(mid_pool)
        random.shuffle(high_pool)
        
        selected.extend(low_pool[:low_target])
        selected.extend(mid_pool[:mid_target])
        selected.extend(high_pool[:high_target])
        
        return sorted(selected)
    
    def _generate_frequency_based(self):
        """Generate based on number frequencies."""
        # Weight by frequency
        weighted_numbers = []
        for num in self.all_numbers:
            freq = self.number_frequencies.get(num, 0)
            weighted_numbers.extend([num] * freq)
        
        selected = []
        available = weighted_numbers.copy()
        
        while len(selected) < 11:
            choice = random.choice(available)
            if choice not in selected:
                selected.append(choice)
                # Remove all instances of this number
                available = [n for n in available if n != choice]
        
        return sorted(selected)
    
    def _generate_balanced(self):
        """Generate with balanced distribution."""
        # Try for 3-4-4 or 4-3-4 pattern
        patterns = [(3, 4, 4), (4, 3, 4), (3, 5, 3), (4, 4, 3)]
        pattern = random.choice(patterns)
        
        low_count, mid_count, high_count = pattern
        
        low_selected = random.sample(self.low_range, low_count)
        mid_selected = random.sample(self.mid_range, mid_count)
        high_selected = random.sample(self.high_range, high_count)
        
        selected = low_selected + mid_selected + high_selected
        return sorted(selected)
    
    def _generate_chaos_based(self):
        """Generate using chaos-crypto TRNG."""
        # Simple chaos-based generation
        seed = int.from_bytes(os.urandom(4), 'big')
        random.seed(seed)
        
        selected = random.sample(self.all_numbers, 11)
        return sorted(selected)

def main():
    # Initialize analyzer
    analyzer = CroatianLotteryAnalyzer()
    
    # Perform comprehensive analysis
    analyzer.analyze_historical_data()
    
    # Generate combinations based on different methods
    print("=" * 60)
    print("GENERATING STATISTICALLY INFORMED COMBINATIONS")
    print("=" * 60)
    print()
    
    methods = [
        ("clustering", "Most Common Clustering Pattern"),
        ("frequency", "Number Frequency Weighted"),
        ("balanced", "Balanced Distribution"),
        ("chaos", "Chaos-Crypto Random")
    ]
    
    for i, (method, description) in enumerate(methods, 1):
        combination = analyzer.generate_statistically_informed_combination(method)
        
        # Analyze the generated combination
        low_count = sum(1 for n in combination if n in analyzer.low_range)
        mid_count = sum(1 for n in combination if n in analyzer.mid_range)
        high_count = sum(1 for n in combination if n in analyzer.high_range)
        
        even_count = sum(1 for n in combination if n % 2 == 0)
        odd_count = 11 - even_count
        
        combination_sum = sum(combination)
        
        print(f"Combination {i}: {description}")
        print(f"Numbers: {combination}")
        print(f"Distribution: Low={low_count}, Mid={mid_count}, High={high_count}")
        print(f"Even/Odd: {even_count} even, {odd_count} odd")
        print(f"Sum: {combination_sum}")
        print()
    
    print("=" * 60)
    print("NOTE: All combinations have equal probability (1 in 705,432)")
    print("Statistical analysis provides systematic selection, not prediction")
    print("=" * 60)

if __name__ == "__main__":
    main()
